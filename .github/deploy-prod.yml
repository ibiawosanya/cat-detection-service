name: Deploy to Production

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      confirm_production:
        description: 'Type "DEPLOY_TO_PRODUCTION" to confirm'
        required: true
        default: ''

env:
  AWS_REGION: eu-west-1
  ENVIRONMENT: prod

jobs:
  validate-deployment:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    steps:
      - name: Validate production deployment confirmation
        run: |
          if [ "${{ github.event.inputs.confirm_production }}" != "DEPLOY_TO_PRODUCTION" ]; then
            echo "❌ Production deployment not confirmed. Exiting."
            exit 1
          fi
          echo "✅ Production deployment confirmed"

  pre-deployment-checks:
    runs-on: ubuntu-latest
    needs: [validate-deployment]
    if: always() && (needs.validate-deployment.result == 'success' || github.event_name == 'push')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Run Full Test Suite
        run: |
          pip install -r requirements.txt
          pip install pytest pytest-cov pytest-xdist
          pytest tests/ --cov=src/ --cov-fail-under=80 -n auto

      - name: Security Audit
        run: |
          pip install bandit safety
          bandit -r src/lambdas/ -ll
          safety check

      - name: Terraform Security Scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'config'
          scan-ref: './terraform'

  backup-production:
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Backup DynamoDB Table
        run: |
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          aws dynamodb create-backup \
            --table-name prod-cat-scan-results \
            --backup-name "pre-deployment-backup-$TIMESTAMP" || true

      - name: Export Current Terraform State
        run: |
          mkdir -p backups
          aws s3 cp s3://cat-detection-terraform-state-777/cat-detection/prod/terraform.tfstate \
            backups/terraform-state-backup-$(date +%Y%m%d-%H%M%S).tfstate

  deploy-production:
    runs-on: ubuntu-latest
    needs: [backup-production]
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: src/web-ui/package-lock.json

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Build Lambda packages
        run: |
          mkdir -p dist
          
          build_lambda() {
            local lambda_name=$1
            echo "Building $lambda_name lambda for production..."
            
            cd src/lambdas/$lambda_name
            
            # Install dependencies with optimizations
            pip install -r requirements.txt -t . --no-deps --implementation cp --only-binary=:all:
            
            # Remove unnecessary files for production
            find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
            find . -name "*.pyc" -delete
            find . -name "*.pyo" -delete
            find . -name "tests" -type d -exec rm -rf {} + 2>/dev/null || true
            
            # Create optimized zip package
            zip -r ../../../dist/$lambda_name.zip . -x "*.git*" "*.md" "*.txt"
            
            cd ../../..
          }
          
          build_lambda "upload"
          build_lambda "process"
          build_lambda "status"

      - name: Terraform Init
        run: |
          cd terraform/environments/prod
          terraform init

      - name: Terraform Plan
        id: plan
        run: |
          cd terraform/environments/prod
          terraform plan -detailed-exitcode -out=tfplan
        continue-on-error: true

      - name: Terraform Plan Status
        if: steps.plan.outcome == 'failure'
        run: exit 1

      - name: Manual Approval for Production
        if: github.event_name == 'workflow_dispatch'
        uses: trstringer/manual-approval@v1
        with:
          secret: ${{ github.TOKEN }}
          approvers: core-team
          minimum-approvals: 1
          issue-title: "🚨 Production Deployment Approval Required"
          issue-body: |
            **Production deployment is pending approval**
            
            **Tag/Version**: ${{ github.ref }}
            **Triggered by**: ${{ github.actor }}
            **Deployment time**: $(date)
            
            Please review the changes and approve if ready to deploy to production.

      - name: Terraform Apply
        run: |
          cd terraform/environments/prod
          terraform apply tfplan

      - name: Get Deployment Outputs
        id: outputs
        run: |
          cd terraform/environments/prod
          API_URL=$(terraform output -raw api_gateway_url)
          echo "api_url=$API_URL" >> $GITHUB_OUTPUT
          WEB_BUCKET=$(terraform output -raw web_bucket_name)
          echo "web_bucket=$WEB_BUCKET" >> $GITHUB_OUTPUT
          CLOUDFRONT_ID=$(terraform output -raw cloudfront_distribution_id)
          echo "cloudfront_id=$CLOUDFRONT_ID" >> $GITHUB_OUTPUT
          WEB_URL=$(terraform output -raw web_url)
          echo "web_url=$WEB_URL" >> $GITHUB_OUTPUT

      - name: Build and Deploy Web UI
        run: |
          cd src/web-ui
          npm ci
          
          # Production build with optimizations
          REACT_APP_API_URL=${{ steps.outputs.outputs.api_url }} \
          GENERATE_SOURCEMAP=false \
          npm run build
          
          # Deploy to S3 with cache headers
          aws s3 sync build/ s3://${{ steps.outputs.outputs.web_bucket }} \
            --delete \
            --cache-control "public,max-age=31536000" \
            --exclude "*.html" \
            --exclude "service-worker.js"
          
          # Deploy HTML files with shorter cache
          aws s3 sync build/ s3://${{ steps.outputs.outputs.web_bucket }} \
            --exclude "*" \
            --include "*.html" \
            --include "service-worker.js" \
            --cache-control "public,max-age=0,s-maxage=86400"
          
          # Invalidate CloudFront
          aws cloudfront create-invalidation \
            --distribution-id ${{ steps.outputs.outputs.cloudfront_id }} \
            --paths "/*"

  post-deployment-verification:
    runs-on: ubuntu-latest
    needs: [deploy-production]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Health Check
        run: |
          API_URL="${{ needs.deploy-production.outputs.api_url }}"
          
          # Wait for deployment to be ready
          sleep 30
          
          # Test API endpoint
          curl -f "$API_URL/health" || exit 1
          
          echo "✅ Health check passed"

      - name: Run Smoke Tests
        run: |
          pip install pytest requests
          export API_URL="${{ needs.deploy-production.outputs.api_url }}"
          python -m pytest tests/smoke/ -v

      - name: Load Test
        run: |
          pip install locust
          export API_URL="${{ needs.deploy-production.outputs.api_url }}"
          
          # Run production load test
          locust -f tests/performance/locustfile.py --host=$API_URL \
            --users 50 --spawn-rate 10 --run-time 300s --headless

  notify-deployment:
    runs-on: ubuntu-latest
    needs: [deploy-production, post-deployment-verification]
    if: always()
    
    steps:
      - name: Notify Success
        if: needs.post-deployment-verification.result == 'success'
        run: |
          echo "🎉 Production deployment successful!"
          # Add Slack/email notification here

      - name: Notify Failure
        if: needs.post-deployment-verification.result == 'failure'
        run: |
          echo "🚨 Production deployment failed!"
          # Add alert notification here